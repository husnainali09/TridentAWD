#####################################################################
# 	                 Cartographer V3 （ADXL345）
#####################################################################

[cartographer]
#   If you are using the CAN Bus version, replace serial: with canbus_uuid: and add the UUID.
canbus_uuid: 302d06391050
speed: 40.
#   Z probing dive speed.
lift_speed: 5.
#   Z probing lift speed.
backlash_comp: 0.00244
#   Backlash compensation distance for removing Z backlash before measuring
#   the sensor response.
x_offset: 0.
#   X offset of cartographer from the nozzle.
y_offset: 21.1
#   Y offset of cartographer from the nozzle.
trigger_distance: 2.
#   cartographer trigger distance for homing.
trigger_dive_threshold: 1.5
#   Threshold for range vs dive mode probing. Beyond `trigger_distance +
#   trigger_dive_threshold` a dive will be used.
trigger_hysteresis: 0.006
#   Hysteresis on trigger threshold for untriggering, as a percentage of the
#   trigger threshold.
cal_nozzle_z: 0.1
#   Expected nozzle offset after completing manual Z offset calibration.
cal_floor: 0.1
#   Minimum z bound on sensor response measurement.
cal_ceil:5.
#   Maximum z bound on sensor response measurement.
cal_speed: 1.0
#   Speed while measuring response curve.
cal_move_speed: 10.
#   Speed while moving to position for response curve measurement.
default_model_name: default
#   Name of default cartographer model to load.
mesh_main_direction: x
#   Primary travel direction during mesh measurement.
#mesh_overscan: -1
#   Distance to use for direction changes at mesh line ends. Omit this setting
#   and a default will be calculated from line spacing and available travel.
mesh_cluster_size: 1
#   Radius of mesh grid point clusters.
mesh_runs: 1
#   Number of passes to make during mesh scan.

[adxl345]
cs_pin: cartographer:PA3        # Chip select pin for ADXL345 accelerometer
spi_bus: spi1                   # SPI bus used for communication

[resonance_tester]
accel_chip: adxl345             # Specifies ADXL345 accelerometer for resonance testing
probe_points:
    175, 175, 20                # Coordinates of the probe points for resonance testing

#####################################################################
##            Autosync 
#####################################################################

[motors_sync]
axes: x,y
#    Axes on which calibration will be performed.
accel_chip: adxl345
#accel_chip_x: adxl345 
#accel_chip_y: adxl345
#    Accelerometers for vibration collection: adxl345 / mpu9250 / lis2dw,
#    etc. Are indicated for each axis on which calibration is performed.
#microsteps: 16
#    Maximum microstepping displacement of the stepper motor rotor. It's
#    not necessary to increase the value above 16 with 20t pulley, these
#    fluctuations are elusive.
#model: quadratic
#    Model of the dependence of the displacement of microsteps on the
#    shaft of a stepper motor depends on the magnitude of the measured
#    oscillations. Supported models: linear, quadratic, cubic, power, root,
#    hyperbolic, exponential.
#model_coeffs: 
#    85.9867386345,3019.1653268982,-2218.6182585730
#    Coefficients above the described model, for calculating microsteps.
#max_step_size: 5
#    The maximum number of microsteps that the motor can take move at time,
#    to achieve the planned magnitude.
#retry_tolerance: 999999
#    The forced threshold to which a pair of stepper motors on one belt
#    will have to lower the magnitude of the oscillations. It's recommended
#    to configure in order to filter possible inaccuracies. After several
#    iterations of starting synchronization, you will find the edge, to
#    which this parameter should be omitted.
#retries: 0
#    Maximum number of repetitions to achieve a forced threshold of motor
#    synchronization deviations.
head_fan: hotend_fan

[gcode_macro SYNC_MOTORS]
rename_existing: SYNC_MOTORS_BASE
gcode:
    {% set axes = params.AXES|default('default')|string|lower %}
    {% set retry_tolerance = params.RETRY_TOLERANCE|default('default')|string|lower %}
    {% set retries = params.THRESHOLD_RETRIES|default('default')|string|lower %}
    {% set force_run = params.FORCE_RUN|default(0)|int %}
    {% if not printer.motors_sync.applied or force_run %}
        {% if axes == 'default' %}
            {% set axes = printer.configfile.config.motors_sync.axes %}
        {% endif %}
        {% if retry_tolerance == 'default' %}
            {% if 'retry_tolerance' in printer.configfile.config.motors_sync %}
                {% set retry_tolerance = printer.configfile.config.motors_sync.retry_tolerance %}
            {% else %}
                {% set retry_tolerance = 0 %}
            {% endif %}
        {% endif %}
        {% if retries == 'default' %}
            {% if 'retries' in printer.configfile.config.motors_sync %}
                {% set retries = printer.configfile.config.motors_sync.retries %}
            {% else %}
                {% set retries = 0 %}
            {% endif %}
        {% endif %}
        SYNC_MOTORS_BASE AXES={axes} RETRY_TOLERANCE={retry_tolerance} RETRIES={retries}
    {% else %}
        M118 Motors sync already applied! If you want force sync, run with FORCE_RUN=1 argument
    {% endif %}

